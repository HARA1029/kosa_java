package june_20.polymorphism;
//44. 추상 클래스
//추상 메소드
// 자식 클래스에서 반드시 오버라이딩해야한 사용가능
// 선언목적 : 추상메소드가 포함된 클래스를 상속받는 자식클래스가 반드시 추상메소드를 구현하기 위함
// 선언부만 존재. 
// 구현부는 작성 x. -> 자식 클래스에서 오버라이딩하여 사용 
// 문법 : abstract 반환타입 메소드이름(); 
//	=> 선언부만 있고 구현부가 없다는 의미로 선언부 끝에 바로 세미콜론 추가

//추상 클래스
//하나 이상의 추상 메소드를 포함하는 클래스 -> 다형성을 가지는 메소드 집합을 정의
// => 반드시 사용되어야하는 메소드를 추상클래스에서 추상메소드로 선언 
//    -> 상속받는 모든클래스에서 반드시 재정의해야함
//문법
//abstract class 클래스명 {
// ...
//	abstract 반환타입 메소드이름();
// ...
// }
//동작이 정의되어 있지 않은 추상메소드 포함 => 인스턴스 생성 불가. 상속을 받기위해 사용됨.
// 상속을 통해 자식클래스 생성 -> 추상클래스의 모든 추상메소드 오버라이딩 -> 자식클래스의 인스턴스 생성 가능
//   =>자식클래스로만 인스턴스 생성가능
// 일반 클래스와 다른 점 : 추상 메소드를 포함하고 있음  => 생성자와 필드, 일반 메소드도 포함 가능

//추상메소드 사용목적
// 추상메소드가 포함된 클래스를 상속받는 자식 클래스가 반드시 추상 메소드를 구현하도록 하기 위함
// 일반 메소드를 구현하면 해당 메소드를 구현해도 안해도 됨
// but  추상 메소드가 포함된 추상 클래스를 상속받은 모든 자식 클래스는 추상 메소드를 구현해야만 인스턴스를 생성 가능
// => 반드시 구현하게 됨

abstract class Animal {
	abstract void cry();
}

class Cat extends Animal {
	void cry( ) {
		System.out.println("냐옹냐옹!");
	}
}
class Dog extends Animal {
	void cry() {
		System.out.println("멍멍!");
	}
}

public class Abstract_Class {
	public static void main(String[] args) {
		//Animal a = new Animal(); //추상클래스는 인스턴스 생성불가
		
		Cat c = new Cat();
		Dog d = new Dog();
		
		c.cry();
		d.cry();
	}

}
